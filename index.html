<!DOCTYPE html>
<html lang="en" style="height:100%">

<head>
    <meta charSet="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="description" content="Artificial intelligence with Mihok from TorontoJS, building on basic knowledge we will discover and build Neural Networks from scratch to get a better understanding of how they work." />
    <title>JS Workshop</title>
    <script type="text/javascript" src="helpers/manifest.lib.js"></script>
    <script type="text/javascript" src="helpers/math.lib.js"></script>
    <script type="text/javascript" src="helpers/data.lib.js"></script>
    <!-- Insert Live Editor here -->
</head>

<body>
  <script type="text/javascript" src="helpers/renderers.lib.js"></script>
  <script type="text/javascript">


// Shared variable names to reference information
const H1 = 0 // Hidden Layer Neuron #1
const H2 = 1 // Hidden Layer Neuron #2
const O1 = 2 // Output Layer #1

const W1 = 0;
const W2 = 1;
// const W3 = 2;
// const W4 = 3;
const W5 = 2; // 4;
const W6 = 3; // 5;
// const W7 = 6;
// const W8 = 7;
const W9 = 4; // 8;
const W10 = 5; // 9;

const I1 = 0;
const I2 = 1;
// const I3 = 2;
// const I4 = 3;

// const B1 = 0;
// const B2 = 1;
// const B3 = 2;

// Our neural network muhaahaahaahaaaa
class Network {

  // The network's fields

  // Our biases
  biases = [
    0, // b1 (hidden1)
    0, // b2 (hidden2)
    0, // b3 (output)
  ];

  // Our weights (w1 to w10)
  weights = [0, 0, 0, 0, 0, 0];
  
  activatorFn = function (x) { throw new Error('not implemented'); };
  lossFn = function (y) { throw new Error('not implemented'); };
  
  hidden = [];
  output;

  constructor (weights = [], bias = [], activateFn, lossFn) {
    this.biases = bias;
    this.weights = weights;
    this.activatorFn = activateFn;
    this.lossFn = lossFn;

    const h1Weights = [
      this.weights[W1],
      this.weights[W2],
      // this.weights[W3],
      // this.weights[W4],
    ];

    const h2Weights = [
      this.weights[W5],
      this.weights[W6],
      // this.weights[W7],
      // this.weights[W8],
    ];

    const o1Weights = [
      this.weights[W9],
      this.weights[W10],
    ];

    // Define our hidden input layers
    this.hidden = [
      new Neuron(h1Weights, this.biases[H1], this.activatorFn),
      new Neuron(h2Weights, this.biases[H2], this.activatorFn),
    ];

    // Define our output neuron, we assume only one output no matter what
    this.output = new Neuron(o1Weights, this.biases[O1], this.activatorFn);
  }

  // train() takes in a set of data to train on, and corrisponding answers 
  train (data = [], answers = [], iterations = 1000, rate = 0.1) {
    let lossData = [];

    for (let i = 0; i < iterations; i += 1) {
      // console.log(`Running iteration #${i}`);
      for (let d in data) {
        // Get our individual neuron data to calculate things
        let sums = [];
        let values = [];

        // Calculate our 1st hidden layer neuron
        sums[H1] = this.hidden[H1].sum(data[d]);
        values[H1] = this.hidden[H1].activatorFn(sums[H1]);

        // Calculate our 2nd hidden layer neuron
        sums[H2] = this.hidden[H2].sum(data[d]);
        values[H2] = this.hidden[H2].activatorFn(sums[H2]);

        // Calcualte our output layer neuron
        sums[O1] = this.output.sum([sums[H1], sums[H2]]);
        values[O1] = this.output.activatorFn(sums[O1]);

        let prediction = values[O1];


        // Now we'll calculate the partial derivatives
        
        let dLDPred = -2 * (answers[d] - prediction);

        // Lets work backwards, i.e. backpropagation


        // Output Neuron

        // w10
        let dPredDW10 = values[H1] * Math.derivSigmoid(sums[O1]);
        // w9
        let dPredDW9 = values[H2] * Math.derivSigmoid(sums[O1]);
        // b3
        let dPredDB3 = Math.derivSigmoid(sums[O1]);

        let dPredDH1 = this.weights[W9] * Math.derivSigmoid(sums[O1]);
        let dPredDH2 = this.weights[W10] * Math.derivSigmoid(sums[O1]);

        
        // Hidden Layer Neuron #2

        // w8
        // let dH2DW8 = data[d][I1] * Math.derivSigmoid(sums[H2]);
        // w7
        // let dH2DW7 = data[d][I2] * Math.derivSigmoid(sums[H2]);
        // w6
        let dH2DW6 = data[d][I1] * Math.derivSigmoid(sums[H2]);
        // w5
        let dH2DW5 = data[d][I2] * Math.derivSigmoid(sums[H2]);
        // b2
        let dH2DB2 = Math.derivSigmoid(sums[H2]);


        // Hidden Layer Neuron #1
        
        // w4
        // let dH1DW4 = data[d][I1] * Math.derivSigmoid(sums[H1]);
        // w3
        // let dH1DW3 = data[d][I2] * Math.derivSigmoid(sums[H1]);
        // w2
        let dH1DW2 = data[d][I1] * Math.derivSigmoid(sums[H1]);
        // w1
        let dH1DW1 = data[d][I2] * Math.derivSigmoid(sums[H1]);
        // b1
        let dH1DB1 = Math.derivSigmoid(sums[H1]);

        // Now let's update our weights and biases to minimize loss
        
        // Output Neuron
        this.weights[W10] -= rate * dLDPred * dPredDW10;
        this.weights[W9] -= rate * dLDPred * dPredDW9;
        // Update our ouput neuron to reflect the new weights
        this.output.weights = [
          this.weights[W10],
          this.weights[W9],
        ];

        this.biases[O1] -= rate * dLDPred * dPredDB3;
        this.output.bias = this.biases[O1];

        // Hidden Layer Neuron #2
        // this.weights[W8] -= rate * dLDPred * dPredDH2 * dH2DW8;
        // this.weights[W7] -= rate * dLDPred * dPredDH2 * dH2DW7;
        this.weights[W6] -= rate * dLDPred * dPredDH2 * dH2DW6;
        this.weights[W5] -= rate * dLDPred * dPredDH2 * dH2DW5;
        // Update our neuron to reflect the new weights
        this.hidden[H2].weights = [
          // this.weights[W8],
          // this.weights[W7],
          this.weights[W6],
          this.weights[W5],
        ];

        this.biases[H2] -= rate * dLDPred * dPredDH2 * dH2DB2;
        this.hidden[H2].bias = this.biases[H2];

        // Hidden Layer Neuron #1
        // this.weights[W4] -= rate * dLDPred * dPredDH1 * dH1DW4;
        // this.weights[W3] -= rate * dLDPred * dPredDH1 * dH1DW3;
        this.weights[W2] -= rate * dLDPred * dPredDH1 * dH1DW2;
        this.weights[W1] -= rate * dLDPred * dPredDH1 * dH1DW1;
        // Update our neuron to reflect the new weights
        this.hidden[H1].weights = [
          // this.weights[W4],
          // this.weights[W3],
          this.weights[W2],
          this.weights[W1],
        ];

        this.biases[H1] -= rate * dLDPred * dPredDH1 * dH1DB1;
        this.hidden[H1].bias = this.biases[H1];
      }

      // Finally lets calculate our loss and output it for sanity
      if (i % 10 === 0) {
        // Generate an array of the output of our network at this time for each
        // row of data, then 
        let currentPrediction = [];
        data.forEach((row) => {
          currentPrediction.push(this.query(row));
        }, this);
        let loss = this.lossFn(answers, currentPrediction);

        lossData.push(loss);

        console.log(`iteration #${i}, loss: ${loss}`);
      }
    }

    console.graph(lossData);
  }

  // run() takes in inputs for a single run of the network, typically done after
  // it has been trained
  query (inputs = []) {
    let params = [];

    // console.log('\nGenerate output from hidden layers');
    for (let h in this.hidden) {
      // console.log(`\nHidden layer #${h}`);
      params.push(this.hidden[h].activate(inputs));
    }

    // console.log('\n Apply output from hidden layers to output layer', params);
    return this.output.activate(params);
  }
}

// Our quintessential neuron! huzah!
class Neuron {

  // The neuron fields
  bias;
  weights;
  fn = function (x) { throw new Error('not implemented'); };

  constructor (weights = [], bias = 0, fn) {
    this.bias = bias;
    this.weights = weights;
    this.activatorFn = fn;
  }

  sum (inputs = []) {
    let buffer = [];
    let output = 0;

    // console.log('input', inputs);
    // console.log('weights', this.weights);
    // console.log('biases', this.bias);

    // Multiply the weights against the inputs
    for (let i in inputs) {
        buffer[i] = inputs[i] * this.weights[i];
    }
    // console.log('\nMultiply weights and inputs', buffer);

    // Add the biases into our output
    for (let b in buffer) {
        output += buffer[b];
    }
    output += this.bias

    return output;
  }

  activate (inputs = []) {
    if (inputs.length !== this.weights.length) {
      throw new Error('input and weight shape mismatch');
    }
   
    let output = 0;

    // console.log('\nAdd all input-weights and bias together', output);
    output = this.sum(inputs);
    
    // Activate the neuron (or not), based on applying the sigmoid function
    // to the output of our inputs, weights, and biases.
    let result = this.activatorFn(output);
    // console.log('Apply sigmoid function to output', result);
    return result;
  }
}

// const w = [0, 1];
// const b = 0;

// const nn = new Network(w, b, Math.sigmoid);

// const x = [2, 3];
// console.log('Run neural network against inputs');
// console.log(nn.run(x));


// Let's generate our training data in a machine-readable form
const data = [];
// for (let row in DATA.weather["2018"]) {
for (let row in DATA.weightHeightGender) {
  data.push([
    // I1
    DATA.weightHeightGender[row].weight,
    // I2
    DATA.weightHeightGender[row].height,
    // I3
    // DATA.weather["2018"][row].minTemp,
    // I4
    // DATA.weather["2018"][row].maxTemp,
  ]);
};

// Let's generate our training "answer" data in a machine-readable form
const answers = [];
// for (let row in DATA.weather["2018"]) {
for (let row in DATA.weightHeightGender) {
  // answers.push(DATA.weather["2018"][row].totalPrecipitation > 0 ? 1 : 0);
  answers.push(DATA.weightHeightGender[row].gender > 0 ? 1 : 0);
}


console.log('Create neural network');
const nn = new Network(
  // weights
  // [0, 0, 0, 0, 0, 0],
  // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [
    Math.nrand(), // w1
    Math.nrand(), // w2
    // Math.random(), // w3
    // Math.random(), // w4
    Math.nrand(), // w5
    Math.nrand(), // w6
    // Math.random(), // w7
    // Math.random(), // w8
    Math.nrand(), // w9
    Math.nrand(), // w10
  ],
  // bias
  // [0, 0, 0],
  [
    Math.nrand(), // b1
    Math.nrand(), // b2
    Math.nrand(), // b3
  ],
  // activation function
  Math.sigmoid,
  // loss function
  Math.meanSquaredError,
);

console.log('Train neural network', data, answers);
nn.train(data, answers, 1000, 0.1)

// console.log('Did it rain on January X, 2019?')
// console.log('Answer', nn.query([1, 1, -5, -12]));

// console.log('Will it rain on April 17, 2019?')
// console.log('Answer', nn.query([4, 17, 1, 7]));

console.log('Is Emily a girl or a boy')
console.log('Answer', nn.query([-7, -3]));

console.log('Is Frank a girl or a boy')
console.log('Answer', nn.query([20, 2]));




  </script>
</body>

</html>
